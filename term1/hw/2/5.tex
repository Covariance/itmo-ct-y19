\section{}
	Опишем алгоритм решения. Для начала заметим, что всего ответов не может быть больше, чем $k-1$, так как в противном случае общее число их вхождений в массив превышает $k\cdot\frac{n}{k} = n$. Создадим массив  для кандидатов размером $k-1$, каждый элемент которого содержит значение кандидата и встреченное нами его количество, изначально нулевое. Пойдем по массиву, считывая $\operatorname{a}[i]$. Выполним следующее:
	\begin{enumerate}
		\item Если элемент с таким значением уже есть среди кандидатов, увеличим его счётчик на $1$.
		\item Если такого элемента нет, но есть элемент с нулевым счётчиком, то заменим его значение на значение $\operatorname{a}[i]$ и выставим счётчик в 1.
		\item Если ни один из элементов не равен $\operatorname{a}[i]$ и все они имеют счётчик хотя бы $1$, то мы нашли группу из $k$ различных элементов. Вычтем из каждого счётчика по 1.
	\end{enumerate}
	В конце исполнения данного алгоритма в массиве кандидатов останутся только ответы, и, быть может, какие-то лишние элементы. Для каждого элемента массива кандидатов проверим, является ли он ответом, пройдясь по $\operatorname{a}[]$.
	
	Покажем, что в результате мы не могли потерять ответ. Так как каждый раз мы удаляли из массива кандидатов ровно $k$ различных элементов, то всего удалений не могло быть больше, чем $\frac{n}{k}$. Таким образом, если элемент встречается больше, чем $\frac{n}{k}$ раз, то он остался в массиве кандидатов с ненулевым счётчиком. Лишний ответ мы дать не могли, так как проверили их все.
	
	Ниже приведён код, реализующий указанный алгоритм за $\mathcal{O}(nk)$ времени и $\mathcal{O}(n + k)$ памяти.
	
	\newpage\lstinputlisting[language=c++]{5.cpp}