\section{}

	Значит так, это вроде просто бинпоиск. Давайте что-нибудь про него докажем, что ли. Делает он следующее:
	
	\begin{enumerate}
		\item Положим $r=1$;
		\item Пока $r$-тый элемент массива меньше, чем $x$, умножаем $r$ на $2$. 
		\item Запускается от полуинтервала $[\frac{r}{2};\;r)$;
		\item Проверяет, в какой половине отрезка находится искомый элемент;
		\item Повторяем 3-5 шаги для этой половинки отрезка;
		\item Когда на отрезке всего один элемент, мы нашли то, что нам надо.
	\end{enumerate}

	В результате первых двух шагов мы сделаем не больше, чем $\log p$ шагов, так как в результате их имеем $\frac{r}{2} < p < r$. Тогда шаги с третьего по шестой суммарно займут $\mathcal{O}(\log \frac{r}{2}) \leq \mathcal{O}(\log p)$. Значит, суммарная асимптотика алгоритма будет равна $\mathcal{O}(\log p)$.
	
	Ниже приведён код с реализацией этого алгоритма.

	\newpage\lstinputlisting[language=c++]{1.cpp}