# Задание 4. Знакомство с модулями в Linux (15 баллов)

Ядро Linux — [монолитное](https://en.wikipedia.org/wiki/Monolithic_kernel). Это означает, что все части работают в одном адресном пространстве. Однако, это не означает, что для добавления какой-то возможности необходимо полностью перекомпилировать ядро. Новую функциональность можно добавить в виде модуля ядра. Такие модули можно легко загружать и выгружать по необходимости прямо во время работы системы.

Наша цель — познакомиться с написанием модулей для ядра Linux.

> Мы рекомендуем при выполнении этого домашнего задания использовать отдельную виртуальную машину: ваша ошибка может вывести всю систему из строя, и вы можете потерять все ваши файлы.

Работоспособность всех инструкций гарантируется для дистрибутива [Ubuntu 16.04 x64](https://releases.ubuntu.com/16.04/ubuntu-16.04.7-desktop-amd64.iso). Если вы используете другой дистрибутив Linux, то со всеми ошибками и особенностями вам придётся разбираться самостоятельно. Обратите внимание, что этот дистрибутив использует ядро версии 4.15. Вы можете просто импортировать [наш образ виртуальной машины](https://yadi.sk/d/PPAk5OFgTXd5Dg) в VirtualBox или VMWare Workstation. В нём sudo-права у пользователя `user` с паролем `123456`.

> Выполняйте задание в ветке `netnod`.

## Подзадание 1. Подготовка

В этом подзадании вы научитесь компилировать и подключать самый простой модуль. Для компиляции кода, работающего в kernel-space, нам понадобятся пакеты с утилитами для сборки, а также заголовочные файлы:

```sh
$ sudo apt-get install build-essential linux-headers-`uname -r`
```

Рассмотрим код простого модуля, который умеет просто загружаться и выгружаться из памяти: [`lkm_example.c`](lkm_example.c).

Последние две строчки кода указывает компилятору, где искать функции, которые инициализируют и удаляют модуль.

```c
module_init(lkm_example_init);
module_exit(lkm_example_exit);
```

В режиме ядра мы не можем совершать системные вызовы, а значит, и использовать библиотечные функции — `printf`, например, делает вызов `write`. Чтобы печатать данные на экран, воспользуемся функцией [`printk`](https://manpages.debian.org/jessie/linux-manual-3.16/printk.9.en.html).

В файле `Makefile` опишем правила для сборки нашего модуля. Одно из правил будет собирать модуль, а второе — удалять артефакты сборки:

```c
obj-m += lkm_example.o
all:
	make -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean
```

> Обратите внимание, что перед командами должен быть символ табуляции: четыре пробела не подойдут.

Теперь попробуем собрать модуль:

```sh
$ sudo make
```

Отлично, в текущей директории появился файл `lkm_example.ko`, который и является нашим модулем. Теперь загрузим его в ядро:

```sh
$ sudo insmod lkm_example.ko
```

Убедимся, что ядро загрузилось:

```sh
$ dmesg
<...>
[  123.456789] Hello, World!
```

Попробуем выгрузить модуль следующей командой и снова проверим вывод `dmesg`:

```sh
$ sudo rmmod lkm_example
$ dmesg
<...>
[  123.987654] Goodbye, World!
```

## Подзадание 2. Бесконечный Hello, World!

Рассмотрим более сложный модуль — он будет реализовывать драйвер некоторого псевдоустройства. Начнём с простого шаблона — [`lkm_device.c`](lkm_device.c). `Makefile` практически не изменится, давайте снова попробуем загрузить модуль:

```sh
$ dmesg
[  123.456789] lkm_device module loaded with device major number 243
```

Устройства в Linux имеют [два идентификатора](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt) — major и minor. Major-идентификатор обозначает тип устройства, а minor — его порядковый номер среди устройств одного типа. В нашем случае minor всегда будет равен нулю (первое устройство), а major мы узнаём при подключении модуля. В нашем случае это значение равно **243**.

В мире Unix [всё — это файл](https://en.wikipedia.org/wiki/Everything_is_a_file), поэтому, чтобы работать с нашим устройством, нам необходимо создать специальный файл (character device file), с помощью которого можно читать данные из устройства.

```sh
$ sudo mknod /dev/lkm_device c 243 0
```

Здесь `/dev/lkm_device` — название файла, `c` обозначает, что устройство символьное, а `243 0` — это major и minor-идентификаторы.

> Устройства бывают *символьными* и *блочными*. Разница в том, что у символьных устройств нет буферизации, и они могут выводить данные любого размера, а у блочных устройств есть буферизация, и данные возвращаются блоками определенного размера.

При попытке прочитать файл получаем следующий бесконечный вывод:

```sh
$ cat /dev/lkm_device
Hello, World!
Hello, World!
Hello, World!
...
```
Для того, чтобы безопасно выгрузить наше ядро, нужно вызвать следующие команды:

```sh
$ sudo rm /dev/lkm_device
$ sudo rmmod lkm_device
```

Попробуйте понять, почему при прочтении файла получается бесконечный вывод нашей строчки. Исправьте модуль таким образом, чтобы команда `cat` выдавала строку только один раз на каждый запрос:

```sh
$ cat /dev/lkm_device
Hello, World!
$ cat /dev/lkm_device
Hello, World!
$
```

> Если вам интересно, попробуйте почитать [исходный код](http://git.savannah.gnu.org/gitweb/?p=coreutils.git;a=blob;f=src/cat.c;h=c7bb7e132c36c0fc800973a0eb00ceea12bcb8a6;hb=master#l147) утилиты `cat`.

## Подзадание 3. Устройство «Буфер»

На самом деле, наш файл `/dev/lkm_device` для остальной операционной системы не сильно-то и отличается от обычного файла. Например, в него можно записать данные. Убедитесь, что устройство подключено, и попробуйте сами:

```sh
echo "Hello, CT!" > /dev/lkm_device
```

Посмотрим на результат:

```sh
$ dmesg
<...>
[ 1234.567890] This operation is not supported.
$ cat /dev/lkm_device
Hello, World!
```

Доработайте модуль таким образом, чтобы из устройства всегда считывалась последняя записанная строка.

* Если в устройство ничего не писали, выводите `Hello, World!`.
* Можете считать, что в устройство всегда записывается строка длиной не более 20 символов.

Пример:

```sh
$ cat /dev/lkm_device
Hello, World!
$ echo "Some test" > /dev/lkm_device
$ cat /dev/lkm_device
Some test
$
```

## Подзадание 4. Сетевое устройство

Устройство, которое просто хранит данные — не очень-то и полезная штука, ведь для этого есть файлы. Научим его чему-то более интересному.

Ваше устройство должно при любой операции чтения отправлять записанные в него данные по протоколу TCP по адресу `45.76.250.10:1337`, и выводить полученный ответ в файл `/tmp/netnod`. Данные, которые вернёт сама операция чтения, не так важны.

Пример:

```sh
$ cat /dev/lkm_device
Hello, World!
$ cat /tmp/netnod
374d794a95cdcfd8b35993185fef9ba368f160d8daf432d08ba9f1ed1e5abe6cc69291e0fa2fe0006a52570ef18c19def4e617c33ce52ef0a6e5fbe318cb0387
$ echo "Hello, World!" | nc 45.76.250.10 1337 > expected.txt
$ diff /tmp/netnod expected.txt
$ echo somerandomstring > /dev/lkm_device
$ cat /dev/lkm_device
somerandomstring
$ cat ans.txt
20e75fbeb33cc6b6ff7d7429ad14f986677cf40df26f0543f9295f94285a190976c48d6f0bf19de124372f0423403fcf84431164f939c80d81d29ac98503600f
```

* Напрямую из ядра системные вызовы делать нельзя, а работать с сетью прямо из ядра сложно. В этом задании вы можете воспользоваться функцией `call_usermodehelper`.
* Обратите внимание, что отправлять вам нужно ровно ту строку, которая была записана в буфер. Не следует добавлять к отправляемым данным различные спецсимволы типа переносов строки и пробелов.

Для запуска тестов вам понадобится Python 3. Добавьте следующие правила в `Makefile`:

```
tests: all
	python3 -m tests BasicTestCases -f

tests-extra: all
	python3 -m tests -f
```

Запустите тесты и проверьте, что ваш модуль работает корректно:

```sh
$ make tests
<...>
Ran 3 tests in 0.233s

OK
```

## Подзадание 5*. Вывод ответа (+4 балла)

Сделайте так, чтобы операция чтения возвращала те же данные, что записываются в файл `/tmp/netnod`. Удалять сам файл при этом не нужно.

Пример:

```sh
$ cat /dev/lkm_device
374d794a95cdcfd8b35993185fef9ba368f160d8daf432d08ba9f1ed1e5abe6cc69291e0fa2fe0006a52570ef18c19def4e617c33ce52ef0a6e5fbe318cb0387
$ echo somerandomstring > /dev/lkm_device
$ cat /dev/lkm_device
20e75fbeb33cc6b6ff7d7429ad14f986677cf40df26f0543f9295f94285a190976c48d6f0bf19de124372f0423403fcf84431164f939c80d81d29ac98503600f
$ cat /tmp/netnod
20e75fbeb33cc6b6ff7d7429ad14f986677cf40df26f0543f9295f94285a190976c48d6f0bf19de124372f0423403fcf84431164f939c80d81d29ac98503600f
```

К бонусному заданию также есть тесты:

```sh
$ make tests-extra
<...>
Ran 5 tests in 0.415s

OK
```

> Помните, что подзадание со звёздочкой сдаётся только вместе с основным.
