\section{}
	Для начала покажем, что среднее время работы операции $\operatorname{contains}$ равняется $\mathcal{O}(k^2)$. Это очевидно следует из того, что применение этой операции не меняет потенциал, а сама она проходит по не больше чем $k$ массивам, на $i$-ом тратя $\mathcal{O}(i)$ времени. Просуммировав по всем $i$, получаем, что $T = \sum_{j=0}^{k} \mathcal{O}(j)$, то есть $\exists A:\;T \leq A\cdot \sum_{j=0}^{k}j = A\cdot \frac{k(k+1)}{2} = \mathcal{O}(k^2)$.
	
	Теперь разберёмся с операцией $\operatorname{add}$. Посчитаем её среднее время работы руками. Представим число $n$ в двоичной форме. Заметим, что каждой единице в его записи соотвтетствует полный массив, а каждому нулю "--- пустой. Таким образом, функция $\operatorname{add}$ проведет операцию $\operatorname{merge}$ для каждого из полных массивов до первого пустого, то есть для каждой единицы до первого нуля. Таким образом, если в числе первые $m$ чисел "--- единицы, то $\operatorname{add}$ проведет $\sum_{j=0}^{m} \mathcal{O}(2^j)$ операций, то есть $\mathcal{O}(2^{m+1})$ (там появляется операция, занимающая $2^0$ времени "--- это присвоение пустому массиву ссылки на смёрженный новый массив).
	
	Посчитаем, сколько всего есть возможных входных данных, на которых в начале стоит ровно $m$ единиц, а после "--- ноль. Поймём, что для $m\,<\,k$ таких будет ровно $2^{k-m-1}$, а для $k\,=\,m$ "--- одна. Таким образом, общее время работы алгоритма на всех входах будет равно:
	
	\begin{gather*}
	\sum_{j=0}^{k-1} \left(2^{k-j-1} \cdot \mathcal{O}(2^{j+1}) \right)+ 1\cdot\mathcal{O}(2^{k+1}) \; =
	\\
	=\; \sum_{j=0}^{k} \mathcal{O}(2^{k}) \;=\; \mathcal{O}(k \cdot 2^k)
	\end{gather*}
	
	Отсюда имеем, так как всего вариантов входных данных в точности $2^k$, что среднее время работы $\operatorname{add}$ будет равно $\frac{\mathcal{O}(k\cdot 2^k)}{2^k} = \mathcal{O}(k) = \mathcal{O}(\log n)$.
	
	