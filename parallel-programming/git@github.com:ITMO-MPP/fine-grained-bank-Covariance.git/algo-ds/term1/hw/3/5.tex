\section{}
	Первым шагом алгоритма будет сортировка массива $p$. Тут есть два варианта "--- уложиться в указанную в задаче асимптотику $\mathcal{O}(n\log m + m)$, но скушать дополнительные $\mathcal{O}(n)$ памяти для того, чтобы использовать count sort (так как элементы массивы $p$ не больше $n$), либо отсортировать его при помощи quick sort, но не кушать память. Мне нравится второй, но от этого принципиально ничего не зависит. Поэтому будем использовать первый.
	
	Итак, мы имеем отсортированный за $\mathcal{O}(m)$ массив $p$. Предложим следующий алгоритм:
	\begin{enumerate}
		\item Рассмотрим средний элемент массива $p$, то есть $p[\frac{m}{2}]$. Найдём его порядковую статистику за $\mathcal{O}(n)$.
		\item За все те же $\mathcal{O}(n)$ сделаем partition по этому элементу. Тогда $\forall i < \frac{m}{2}$ порядковая статистика $p[i]$ будет лежать в левой части массива после partition, а для $\forall j > \frac{m}{2}$ порядковая статистика $p[j]$ будет лежать в правой части. Рекурсивно вызовемся от левой части и нижней половины массива $p$ и от правой части и верхней половины массива $p$.
	\end{enumerate}
	
	Очевидно, что вышеописанный алгоритм находит все порядковые статистики. Теперь докажем его асимптотику. Сортировка массива $p$ проходит отдельно за $\mathcal{O}(m)$. Теперь решим рекурренту. Так как я не умею решать её по-человечески, решим почти графически. Поймём, что глубина рекурсии будет равна $\log m$, так как мы уменьшаем массив $p$ в два раза для каждого следующего шага, а на каждом её уровне алгоритм совершает $\mathcal{O}(n)$ действий "--- поиск средней порядковой статистики в каждом массиве и новый partition. Таким образом, эта часть алгоритма работает за $\mathcal{O}(n\log m)$, суммарная асимптотика $\mathcal{O}(n\log m + m)$. 