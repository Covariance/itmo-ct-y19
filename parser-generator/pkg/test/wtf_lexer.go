// Code generated by go-parser-generator. DO NOT EDIT.

package parser

import (
	"fmt"
	"regexp"
)

type wtfLexer struct {
	input    string
	pos      int
	curToken Token
}

type TokenKind int

const (
	KIND TokenKind = iota
	END TokenKind = iota
)

func (r TokenKind) String() string {
    
    if r == KIND {
        return "KIND"
    }
    
    return "END"
}

type Token struct {
	kind  TokenKind
	value string
}

type TokenPattern struct {
	kind    TokenKind
	pattern *regexp.Regexp
}

var WHITESPACE = regexp.MustCompile("^\\s")

var ORDER = []TokenPattern{{kind: KIND, pattern: regexp.MustCompile("^R")},}

func (r *wtfLexer) Current() Token {
	return r.curToken
}

func (r *wtfLexer) HasNext() bool {
	return r.curToken.kind != END
}

func (r *wtfLexer) MatchRegex(regex *regexp.Regexp) *string {
	if r.pos == len(r.input) {
		return nil
	}

	pos := regex.FindStringIndex(r.input[r.pos:])
	if len(pos) == 0 {
		return nil
	}

	result := r.input[r.pos : r.pos+pos[1]]
	r.pos += pos[1]

	return &result
}

func (r *wtfLexer) NextToken() (Token, error) {
	if r.pos == len(r.input) {
		r.curToken = Token{
			kind:  END,
			value: "",
		}
		return r.curToken, nil
	}

	_ = r.MatchRegex(WHITESPACE)

	for _, pattern := range ORDER {
		if parsed := r.MatchRegex(pattern.pattern); parsed != nil {
			r.curToken = Token{
				kind:  pattern.kind,
				value: *parsed,
			}
			return r.curToken, nil
		}
	}

	return Token{}, fmt.Errorf("unable to parse input: illegal character at position %d", r.pos)
}

}
)
}
