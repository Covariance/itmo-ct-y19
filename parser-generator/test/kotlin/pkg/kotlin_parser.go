// Code generated by GOSPOD parser generator. DO NOT EDIT.

package parser

import "fmt"

type kotlinParser struct {
	lexer kotlinLexer
}

func (r *kotlinParser) Parse() (Tree, error) {
	_, err := r.lexer.NextToken()
	if err != nil {
		return nil, fmt.Errorf("unable to get token from lexer: %w", err)
	}

	res, err := r.fun()
	if err != nil {
		return nil, fmt.Errorf("unable to parse input: %w", err)
	}

	if r.lexer.Current().kind != END {
		return nil, fmt.Errorf("expecting end of input, got: %s", r.lexer.Current().kind.String())
	}

	return &res, nil
}


type funTree struct {
    BaseTree
    
}

type argTree struct {
    BaseTree
    
}

type argsTree struct {
    BaseTree
    
}

type tailTree struct {
    BaseTree
    
}



func (r *kotlinParser) tail(

) (tailTree, error) {
    res := tailTree{
        BaseTree: BaseTree{Node: "tail"},
    }

    token := r.lexer.Current()

    switch token.kind {
        
        case COMA:
            res.SetChildren(append(res.GetChildren(), &BaseTree{Node: "COMA:" + token.value}))
_, err0 := r.lexer.NextToken()
if err0!= nil {
	return tailTree{}, fmt.Errorf("unable to get token from lexer: %w", err0)
}
res1, err := r.arg()
if err != nil {
	return tailTree{}, fmt.Errorf("unable to parse arg in tail: %w", err)
}
res.SetChildren(append(res.GetChildren(), &res1))
res2, err := r.tail()
if err != nil {
	return tailTree{}, fmt.Errorf("unable to parse tail in tail: %w", err)
}
res.SetChildren(append(res.GetChildren(), &res2))

        
        case RBR:
            res.SetChildren(append(res.GetChildren(), &BaseTree{Node: "EPS:" + token.value}))

        
        default:
            return tailTree{}, fmt.Errorf("expected one of [ COMA RBR ], got: %s", token.kind.String())
    }

    return res, nil
}

func (r *kotlinParser) fun(

) (funTree, error) {
    res := funTree{
        BaseTree: BaseTree{Node: "fun"},
    }

    token := r.lexer.Current()

    switch token.kind {
        
        case FUN:
            res.SetChildren(append(res.GetChildren(), &BaseTree{Node: "FUN:" + token.value}))
_, err0 := r.lexer.NextToken()
if err0!= nil {
	return funTree{}, fmt.Errorf("unable to get token from lexer: %w", err0)
}
res.SetChildren(append(res.GetChildren(), &BaseTree{Node: "NAME:" + token.value}))
_, err1 := r.lexer.NextToken()
if err1!= nil {
	return funTree{}, fmt.Errorf("unable to get token from lexer: %w", err1)
}
res.SetChildren(append(res.GetChildren(), &BaseTree{Node: "LBR:" + token.value}))
_, err2 := r.lexer.NextToken()
if err2!= nil {
	return funTree{}, fmt.Errorf("unable to get token from lexer: %w", err2)
}
res3, err := r.args()
if err != nil {
	return funTree{}, fmt.Errorf("unable to parse args in fun: %w", err)
}
res.SetChildren(append(res.GetChildren(), &res3))
res.SetChildren(append(res.GetChildren(), &BaseTree{Node: "RBR:" + token.value}))
_, err4 := r.lexer.NextToken()
if err4!= nil {
	return funTree{}, fmt.Errorf("unable to get token from lexer: %w", err4)
}

        
        default:
            return funTree{}, fmt.Errorf("expected one of [ FUN ], got: %s", token.kind.String())
    }

    return res, nil
}

func (r *kotlinParser) arg(

) (argTree, error) {
    res := argTree{
        BaseTree: BaseTree{Node: "arg"},
    }

    token := r.lexer.Current()

    switch token.kind {
        
        case NAME:
            res.SetChildren(append(res.GetChildren(), &BaseTree{Node: "NAME:" + token.value}))
_, err0 := r.lexer.NextToken()
if err0!= nil {
	return argTree{}, fmt.Errorf("unable to get token from lexer: %w", err0)
}
res.SetChildren(append(res.GetChildren(), &BaseTree{Node: "DOUBLEDOT:" + token.value}))
_, err1 := r.lexer.NextToken()
if err1!= nil {
	return argTree{}, fmt.Errorf("unable to get token from lexer: %w", err1)
}
res.SetChildren(append(res.GetChildren(), &BaseTree{Node: "NAME:" + token.value}))
_, err2 := r.lexer.NextToken()
if err2!= nil {
	return argTree{}, fmt.Errorf("unable to get token from lexer: %w", err2)
}

        
        default:
            return argTree{}, fmt.Errorf("expected one of [ NAME ], got: %s", token.kind.String())
    }

    return res, nil
}

func (r *kotlinParser) args(

) (argsTree, error) {
    res := argsTree{
        BaseTree: BaseTree{Node: "args"},
    }

    token := r.lexer.Current()

    switch token.kind {
        
        case NAME:
            res0, err := r.arg()
if err != nil {
	return argsTree{}, fmt.Errorf("unable to parse arg in args: %w", err)
}
res.SetChildren(append(res.GetChildren(), &res0))
res1, err := r.tail()
if err != nil {
	return argsTree{}, fmt.Errorf("unable to parse tail in args: %w", err)
}
res.SetChildren(append(res.GetChildren(), &res1))

        
        case RBR:
            res.SetChildren(append(res.GetChildren(), &BaseTree{Node: "EPS:" + token.value}))

        
        default:
            return argsTree{}, fmt.Errorf("expected one of [ NAME RBR ], got: %s", token.kind.String())
    }

    return res, nil
}

