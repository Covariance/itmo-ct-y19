\section{}

	Алгоритм для массива $[a;\;b]$ будет таков:
	\begin{enumerate}
		\item Выбрать пару разделительных элементов $l$ и $r$ в массиве;
		\item Посчитать количество отрезков с суммой, не превышающей $k$, таких, что они содержат оба разделительных элемента;
		\item Запуститься рекурсивно от массивов $[a;\;l]$ и $[r;\;b]$, добавить результат на них к общей сумме;
		\item Вернуть ответ. 
	\end{enumerate}

	Для доказательства алгоритма поймём, что при наличии разделительных элементов все отрезки можно поделить на три типа:
	\begin{itemize}
		\item Захватывающие левый;
		\item Захватываюшие правый;
		\item Захватывающие оба.
	\end{itemize}
	Как несложно заметить, подсчёт первых двух типов происходит в рекурсивных вызовах, а третьего "--- на втором шаге. Покажем, как это делается за линейное время при помощи метода двух указателей:

	\begin{lstlisting}[language=Python]
		countInBothParts(div, partSize):
			int leftmost = div - 1, rightmost = div
			int sum = arr[div - 1] + arr[div]
			int retval = 0
			while sum <= k and leftmost >= div - partSize:
				leftmost -= 1
				sum += arr[leftmost]
			while sum <= k and rightmost < div + partSize:
				rightmost += 1
				sum += arr[rightmost]
			while leftmost < div:
				retval += rightmost - div + 1
				sum -= arr[leftmost]
				leftmost += 1
				while sum <= k and rightmost < div + partSize:
					rightmost += 1
					sum += arr[rightmost]
			return retval
				
	\end{lstlisting}
	
	Приведенный код для каждой возможной левой границы самую дальнюю возможную правую границу отрезка, затем добавляет все меньшие отрезки к ответу, а затем переходит к следующей левой границе, проходя все возможные из них.
	
	Теперь найдём асимптотику этого алгоритма. Два указателя работают за $\mathcal{O}(n)$, и, брать за разделительные элементы центральные, то суммарная асимптотика будет $T(n) = 2T(\frac{n}{2}) + n = \mathcal{O}(n\log n)$.
	
	\textbf{\textit{Но это плохой алгоритм, который вообще можно было бы исполнить за линию. А ещё он работает только для неотрицательных элементов массива. Теперь решим нормально.}}
	
	Заменим массив на массив префиксных сумм, это делается за $\mathcal{O}(n)$. Запустим на этом массиве merge sort со следующей модификацией: помимо возврата отсортированных половинок массива алгоритм будет возвращать также и количество подходящих нам отрезков, полностью лежащих внутри этих половинок. Покажем, как можно сделать это за $\mathcal{O}(n)$, если мы имеем две отсортированных половинки массива:
	
	\begin{enumerate}
		\item Рассмотрим самый большой элемент левого массива $l_n$;
		\item До тех пор, пока $l_n-r_i \leq k$, где $r_i$ "--- элемент правого массива под номером $i$, начиная с $1$, увеличиваем $i$. Останавливаемся на последнем элементе, для которого это верно (или вообще на самом последнем, если для него тоже верно);
		\item Заметим, что все отрезки, концам которых соответствуют суммы $l_n$ и $r_j$, где $j \leq i$, подходят нам. Их будет в точности $i$ штук, прибавим это значение к результату на этом отрезке;
		\item Перейдём к следующему по величине элементу левого массива $l_{n-1}$;
		\item Будем уменьшать $i$, до тех пор пока неравенство $l_{n-1} - r_i \leq k$ снова не выполнится (возможно, оно сразу будет выполняться);
		\item Опять же, нам подходят все отрезки, концам которых соответствуют суммы $l_{n-1}$ и $r_j$, где $j \leq i$. Их будет $i$ штук, прибавим это значение к результату на отрезке.
		\item Повторим пункты 4-6 до тех пор, пока не дойдём до $l_1$.
	\end{enumerate}

	При помощи вышеописанного применения метода двух указателей на массиве мы посчитаем количество отрезков, подходящих нам и проходящих через центр. Рекурсивные вызовы от обеих половинок же уже посчитали количество подходящих отрезков, не проходящих через центр. Победа.
	