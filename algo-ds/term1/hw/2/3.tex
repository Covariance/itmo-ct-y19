\section{}
	Идея решения такова "--- вместе с оригинальным ( $\operatorname{original}$) массивом инициализируем два массива такой же длины "---  $\operatorname{iter}$ и  $\operatorname{filled}$ и будем поддерживать количество уже инициализированных элементов  $\operatorname{cnt}$. Когда мы делаем  $\operatorname{set}$ какого-либо элемента  $\operatorname{original}$, который мы ещё не трогали, в ячейку с таким же номером в  $\operatorname{iter}$ кладём  $\operatorname{cnt}$, а в ячейку  $\operatorname{filled}$ с номером  $\operatorname{cnt}$ кладём позицию самого элемента и увеличиваем  $\operatorname{cnt}$.
	
	Теперь посмотрим, как мы будем проверять, инициализирован ли элемент на позиции  $i$. Если да, то ячейка массива $\operatorname{iter}$, на которую указывает  $\operatorname{filled}[i]$, лежит в пределе уже заполненных и должна указывать на  $i$. Почему такого не может случиться, если элемент неинициализирован, очевидно "--- первые  $\operatorname{cnt}$ элементов массива  $\operatorname{filled}$ указывают только на уже инициализированные элементы. Ниже приведён код, реализующий эту структуру данных.
	
	\lstinputlisting[language=c++]{3.cpp}