\section{}
	Воспользуемся методом двух указателей. Будем поддерживать $l$ и $r$ "--- левую и правую границы рабочего отрезка соответственно, а так же $cnt[]$ "--- количества элементов каждого типа на рабочем отрезке. Теперь опишем сам алгоритм:
	
	\begin{enumerate}
		\item Двигаем правую границу массива, пока на нём меньше $k$ различных элементов: когда проходим по элементу, увеличиваем его счётчик на $1$, если раньше счётчик был $0$, то количество различных на рабочем отрезке увеличилось на $1$.
		\item Записываем позицию, на которой количество различных элементов на отрезке впервые стало равно $k$ "--- $leftBorder$;
		\item Идём дальше по массиву, пока количество различных элементов равно $k$, записывая последнюю позицию, на которой это выполняется "--- $rightBorder$. Сейчас в массиве $cnt[]$ лежат элементы с отрезка $[l;\; rightBorder]$.
		\item После этого начинаем двигать $l$ направо пока количество различных элементов равно $k$. Эта часть делится на два этапа "--- до тех пор, пока мы не дошли до $leftBorder$.
	\end{enumerate}

	То, что этот алгоритм работает за $\mathcal{O}(n)$ очевидно "--- оба указателя проходят по каждому элементу не больше одного раза. Почему он находит ответ правильно, тоже очевидно "--- он находит \textit{максимальный} отрезок, на котором ровно $k$ различных элементов, и добавляет.
	
	\textbf{\textit{А пусть он ничего не добавляет, решение-то неправильное. Давайте нормальное покажу.}}
	
	
	Давайте решать немного другую задачу "--- будем считать, сколько всего есть непустых подотрезков, на которых различных элементов \textit{не больше}, чем $k$. Назовём их количество $S_k$.
	Это довольно просто, и делается теми же двумя указателями, поддерживащими всё тот же массив $cnt[]$. Будем для каждой левой границы находить все правые границы, которые нам подходят:
	
	\begin{enumerate}
		\item Двигаем правую границу, пока у нас на отрезке не окажется $>k$ различных элементов.
		\item Поймём, что теперь $[l;r)$ и все подотрезки вида $[l; r']$, где $r' \le r$. Добавим их количество к ответу. Всего их будет $r-l$.
		\item Сдвинем левую границу на один и перейдём к пункту $1$.
	\end{enumerate}

	Для того, чтобы вернуться к исходной задаче, нам достаточно посчитать $S_k$ и $S_{k-1}$, тогда искомое значение просто будет равно $S_k - S_{k-1}$, так как первое включает в себя все отрезки с не менее, чем $k$ элементами, а второе "--- с не более, чем $k-1$, значит их разницу составляют только отрезки с ровно $k$ элементами. Ассимптотикой этого решения будет $\mathcal{O}(n)$, так как мы совершаем два прохода двумя указателями по массиву, а это не больше, чем $4n$ итераций алгоритма. 
	
	\textbf{P.S.:} для $k = 1$ достаточно посчитать только $S_1$, так как оно и будет ответом. А $S_0$ не существует.