// Code generated by GOSPOD parser generator. DO NOT EDIT.

package parser

import (
	"fmt"
	"regexp"
)

type calculatorLexer struct {
	input    string
	pos      int
	curToken Token
}

func NewLexer(input string) calculatorLexer {
    lex := calculatorLexer{
        input: input,
        pos : 0,
    }

    return lex
}

type TokenKind int

const (
	
	POW TokenKind = iota
	
	PLUS TokenKind = iota
	
	MINUS TokenKind = iota
	
	MUL TokenKind = iota
	
	EXCL TokenKind = iota
	
	EPS TokenKind = iota
	
	LB TokenKind = iota
	
	RB TokenKind = iota
	
	DIV TokenKind = iota
	
	DIGIT TokenKind = iota
	END TokenKind = iota
)

func (r TokenKind) String() string {
    
    if r == POW {
        return "POW"
    }
    
    if r == PLUS {
        return "PLUS"
    }
    
    if r == MINUS {
        return "MINUS"
    }
    
    if r == MUL {
        return "MUL"
    }
    
    if r == EXCL {
        return "EXCL"
    }
    
    if r == EPS {
        return "EPS"
    }
    
    if r == LB {
        return "LB"
    }
    
    if r == RB {
        return "RB"
    }
    
    if r == DIV {
        return "DIV"
    }
    
    if r == DIGIT {
        return "DIGIT"
    }
    
    return "END"
}

type Token struct {
	kind  TokenKind
	value string
}

func (r *Token) GetValue() string {
    return r.value
}

type TokenPattern struct {
	kind    TokenKind
	pattern *regexp.Regexp
}

var WHITESPACE = regexp.MustCompile("^\\s")

var ORDER = []TokenPattern{
	
	{kind: POW, pattern: regexp.MustCompile("^\\*\\*")},
	
	{kind: PLUS, pattern: regexp.MustCompile("^\\+")},
	
	{kind: MINUS, pattern: regexp.MustCompile("^-")},
	
	{kind: MUL, pattern: regexp.MustCompile("^\\*")},
	
	{kind: EXCL, pattern: regexp.MustCompile("^!")},
	
	{kind: EPS, pattern: regexp.MustCompile("^EPS")},
	
	{kind: LB, pattern: regexp.MustCompile("^\\(")},
	
	{kind: RB, pattern: regexp.MustCompile("^\\)")},
	
	{kind: DIV, pattern: regexp.MustCompile("^/")},
	
	{kind: DIGIT, pattern: regexp.MustCompile("^[0-9]+")},
	
}

func (r *calculatorLexer) Current() Token {
	return r.curToken
}

func (r *calculatorLexer) HasNext() bool {
	return r.curToken.kind != END
}

func (r *calculatorLexer) MatchRegex(regex *regexp.Regexp) *string {
	if r.pos == len(r.input) {
		return nil
	}

	pos := regex.FindStringIndex(r.input[r.pos:])
	if len(pos) == 0 {
		return nil
	}

	result := r.input[r.pos : r.pos+pos[1]]
	r.pos += pos[1]

	return &result
}

func (r *calculatorLexer) NextToken() (Token, error) {
	if r.pos == len(r.input) {
		r.curToken = Token{
			kind:  END,
			value: "",
		}
		return r.curToken, nil
	}

	_ = r.MatchRegex(WHITESPACE)

	for _, pattern := range ORDER {
		if parsed := r.MatchRegex(pattern.pattern); parsed != nil {
			r.curToken = Token{
				kind:  pattern.kind,
				value: *parsed,
			}
			return r.curToken, nil
		}
	}

	return Token{}, fmt.Errorf("unable to parse input: illegal character at position %d", r.pos)
}
