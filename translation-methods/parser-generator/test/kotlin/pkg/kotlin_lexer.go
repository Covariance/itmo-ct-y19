// Code generated by GOSPOD parser generator. DO NOT EDIT.

package parser

import (
	"fmt"
	"regexp"
)

type kotlinLexer struct {
	input    string
	pos      int
	curToken Token
}

func NewLexer(input string) kotlinLexer {
    lex := kotlinLexer{
        input: input,
        pos : 0,
    }

    return lex
}

type TokenKind int

const (
	
	EPS TokenKind = iota
	
	LBR TokenKind = iota
	
	RBR TokenKind = iota
	
	COMA TokenKind = iota
	
	DOUBLEDOT TokenKind = iota
	
	FUN TokenKind = iota
	
	NAME TokenKind = iota
	END TokenKind = iota
)

func (r TokenKind) String() string {
    
    if r == EPS {
        return "EPS"
    }
    
    if r == LBR {
        return "LBR"
    }
    
    if r == RBR {
        return "RBR"
    }
    
    if r == COMA {
        return "COMA"
    }
    
    if r == DOUBLEDOT {
        return "DOUBLEDOT"
    }
    
    if r == FUN {
        return "FUN"
    }
    
    if r == NAME {
        return "NAME"
    }
    
    return "END"
}

type Token struct {
	kind  TokenKind
	value string
}

func (r *Token) GetValue() string {
    return r.value
}

type TokenPattern struct {
	kind    TokenKind
	pattern *regexp.Regexp
}

var WHITESPACE = regexp.MustCompile("^\\s")

var ORDER = []TokenPattern{
	
	{kind: EPS, pattern: regexp.MustCompile("^EPS")},
	
	{kind: LBR, pattern: regexp.MustCompile("^\\(")},
	
	{kind: RBR, pattern: regexp.MustCompile("^\\)")},
	
	{kind: COMA, pattern: regexp.MustCompile("^,")},
	
	{kind: DOUBLEDOT, pattern: regexp.MustCompile("^:")},
	
	{kind: FUN, pattern: regexp.MustCompile("^fun ")},
	
	{kind: NAME, pattern: regexp.MustCompile("^[A-Za-z]+")},
	
}

func (r *kotlinLexer) Current() Token {
	return r.curToken
}

func (r *kotlinLexer) HasNext() bool {
	return r.curToken.kind != END
}

func (r *kotlinLexer) MatchRegex(regex *regexp.Regexp) *string {
	if r.pos == len(r.input) {
		return nil
	}

	pos := regex.FindStringIndex(r.input[r.pos:])
	if len(pos) == 0 {
		return nil
	}

	result := r.input[r.pos : r.pos+pos[1]]
	r.pos += pos[1]

	return &result
}

func (r *kotlinLexer) NextToken() (Token, error) {
	if r.pos == len(r.input) {
		r.curToken = Token{
			kind:  END,
			value: "",
		}
		return r.curToken, nil
	}

	_ = r.MatchRegex(WHITESPACE)

	for _, pattern := range ORDER {
		if parsed := r.MatchRegex(pattern.pattern); parsed != nil {
			r.curToken = Token{
				kind:  pattern.kind,
				value: *parsed,
			}
			return r.curToken, nil
		}
	}

	return Token{}, fmt.Errorf("unable to parse input: illegal character at position %d", r.pos)
}
